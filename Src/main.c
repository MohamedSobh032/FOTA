/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "LSTD_TYPES.h"
#include "LBIT_MATH.h"
#include "MRCC_Interface.h"
#include "MGPIO_Interface.h"
#include "MSTK_Interface.h"
#include "MUSART_Interface.h"
#include "MFMI_Interface.h"
#include "SHPR_Interface.h"
#include "main.h"

/********************************* READ ONLY GLOBAL VARIABLES *********************************/
static p8 CIPSTART = "AT+CIPSTART=\"TCP\",\"69.197.143.14\",80\r\n";
/**********************************************************************************************/

/************************************ VARIABLE DEFINITIONS ************************************/
u8 BOOT_u8DataRecord[115] = {0};
u8 BOOT_u8AddressBuffer[8] = {0};
u32 BOOT_u32Address = 0;
u8 BOOT_u8Buffer = 0;
u8 BOOT_u8ContFlag = 0;
u8 BOOT_u8RecordLength = 0;
u8 BOOT_u8TimeOut = 0;
u8 BOOT_u8CounterD0 = '0';
u8 BOOT_u8CounterD1 = '0';
u8 BOOT_u8CounterD2 = '0';
/**********************************************************************************************/

/************************************ FUNCTION DEFINITIONS ************************************/
void BOOT_vHWReset(void);				//done
void BOOT_vInitESP(void);				//done
void BOOT_vInit(void);					//done
void BOOT_vGetFirmwareStatus(void);		//done
void BOOT_vEraseSectors(void);
void BOOT_vJumpToApplicationCode(void);
void BOOT_vReceiveDataRecord(void);		//done
void BOOT_vFlashRecord(void);			//done
void BOOT_vUpdateFirmwareStatus(void);	//done
void BOOT_vCloseConnection();			//done
/**********************************************************************************************/

int main(void) {
	BOOT_vInit();
	if (BOOT_u8Buffer == 'O') { BOOT_vJumpToApplicationCode(); }
	else if (BOOT_u8Buffer == 'N') {
		BOOT_u32Address = SHPR_u32ParseAddress(BOOT_u8AddressBuffer);
		BOOT_vEraseSectors();
		while (true) {
    		BOOT_vReceiveDataRecord();
    		/* Parse and Flash */
    		BOOT_vFlashRecord();
    		/* Restart the Buffer */
    		BOOT_u8DataRecord[20] = 0; BOOT_u8DataRecord[21] = 0;
    		/* Ensure That Connection is Closed */
    		BOOT_vCloseConnection();
    		/* Increment the Counter */
    		BOOT_u8CounterD0 += 2;
    		if (BOOT_u8CounterD0 >= 58) {
    			BOOT_u8CounterD0 -= 10; BOOT_u8CounterD1++;
    			if (BOOT_u8CounterD1 >= 58) { BOOT_u8CounterD1 -= 10; BOOT_u8CounterD2++; }
    		}
    		/* Check if it was the Last Record Received */
    		if (BOOT_u8DataRecord[30] == '1' || BOOT_u8DataRecord[43+(BOOT_u8RecordLength*2)] == '1') {
				/* Set the Status of the Firmware to Old
				 * So When Fetching Again, it Does Not Update it
				 */
    			BOOT_vUpdateFirmwareStatus();
    			BOOT_vJumpToApplicationCode();
    		}
    	}
	}
}

void BOOT_vHWReset(void) {
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_HIGH);
	MSTK_vBusyWait(ESP8266_RESET_DELAY);
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_LOW);
	MSTK_vBusyWait(ESP8266_RESET_DELAY);
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_HIGH);
}

void BOOT_vInitESP(void) {
	BOOT_vHWReset();
	do {
		BOOT_u8ContFlag = 0;
		BOOT_u8TimeOut = 0;
		MUSART_vTransmitString(ESP8266_USART, (u8*)"ATE0\r\n");
		/* Read the Buffer */
		while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
			MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
			if (BOOT_u8Buffer == 'O') { 										/* if 'O', Read Next Element */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }		/* 'K' Means '\r\nOK' --> break */
			} else if (BOOT_u8Buffer == 'R') {									/* if 'R', Read the Next Element */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'R') { BOOT_u8ContFlag = 0; break; }		/* 'K' Means '\r\nERROR' --> break */
			} else if (BOOT_u8Buffer == 'b') { BOOT_vHWReset(); break; }		/* 'b' Means 'busy' --> Reset the Module */
			BOOT_u8TimeOut++;
		}
	} while(BOOT_u8ContFlag == 0);
	/* Set Station Mode */
	do {
		BOOT_u8ContFlag = 0;
		BOOT_u8TimeOut = 0;
		MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CWMODE=1\r\n");
		/* Read the Buffer */
		while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
			MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
			if (BOOT_u8Buffer == 'O') { 										/* if 'O', Read Next Element */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }		/* 'K' Means '\r\nOK' --> break */
			} else if (BOOT_u8Buffer == 'R') {									/* if 'R', Read the Next Element */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'R') { BOOT_u8ContFlag = 0; break; }		/* 'K' Means '\r\nERROR' --> break */
			} else if (BOOT_u8Buffer == 'b') { BOOT_vHWReset(); break; }		/* 'b' Means 'busy' --> Reset the Module */
			BOOT_u8TimeOut++;
		}
	} while(BOOT_u8ContFlag == 0);
}

void BOOT_vInit(void) {
	/* Initialize System Clock */
	MRCC_vInitSysAndBusClock();
	/* Enable Wanted Peripherals Clock */
	MRCC_vEnablePeriphClock(MRCC_BUS_AHB1, MRCC_AHB1_GPIOAEN);
	MRCC_vEnablePeriphClock(MRCC_BUS_AHB1LP, MRCC_AHB1LP_FLITFLPEN);
	MRCC_vEnablePeriphClock(ESP8266_PERI_CLOCK);
	/* Initialize Used Pins */
	MGPIO_vSetPinMode(ESP8266_RESET_PIN, MGPIO_MODE_OUTPUT);
	MGPIO_vSetPinOutputSpeed(ESP8266_RESET_PIN, MGPIO_LOW_SPEED);
	MGPIO_vSetPinOutputType(ESP8266_RESET_PIN, MGPIO_OUTPUT_TYPE_PP);
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_HIGH);
	MGPIO_vSetPinMode(ESP8266_USART_TX, MGPIO_MODE_ALTERNATE);
	MGPIO_vSetPinMode(ESP8266_USART_RX, MGPIO_MODE_ALTERNATE);
	MGPIO_vSetPinAFDirection(ESP8266_USART_TX, ESP8266_USART_TX_AF);
	MGPIO_vSetPinAFDirection(ESP8266_USART_RX, ESP8266_USART_RX_AF);
	/* Initialize USART */
	MUSART_InitTypeDef uart = ESP8266_USART_INIT_STRUCTURE;
	MUSART_ClockInitTypeDef uart_clock = {MUSART_DISABLE, 0, 0, 0};
	MUSART_vInit(ESP8266_USART, &uart, &uart_clock);
	MUSART_vEnable(ESP8266_USART);
	MUSART_vRxIntStatus(ESP8266_USART, MUSART_DISABLE);
	/* Initialize Systick for the Busy Flag */
	MSTK_vInit();
	/* Initialize Flash Driver */
	MFMI_vInit();
	/* Initialize ESP8266 Settings */
	BOOT_vInitESP();
}

void BOOT_vGetFirmwareStatus(void) {
	do {
		/* Connect using TCP Protocol */
		do {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)CIPSTART);
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }				/* 'b' Means 'busy' --> Reset the Module */
				else if (BOOT_u8Buffer == 'O') {									/* if 'O', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }		/* 'K' Means 'CONNECT\r\nOK' --> break */
					else if (BOOT_u8Buffer == 'R') {BOOT_u8ContFlag = 0; break; }	/* 'R' Means 'ERROR' --> Connect Again */
				}
				else if (BOOT_u8Buffer == 'Y') {									/* if 'Y', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == ' ') { BOOT_u8ContFlag = 1; break; }		/* ' ' Means 'ALREADY CONNECTED' --> break */
				}
				BOOT_u8TimeOut++;
			}
		} while(BOOT_u8ContFlag == 0);
		/* TCP is now Connected, Send Data Length
		 * AT+CIPSEND=<DataLength>
		 * BOOT_u8ContFlag = 2 --> Skip Data Get URL Command
		 */
		do {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=49\r\n");
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'v') { BOOT_u8ContFlag = 2; break; }			/* 'v' Means 'link is not valid' --> Connect Again */
				else if (BOOT_u8Buffer == 'O') {									/* if 'O', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }		/* 'K' Means '\r\nOK' --> break */
				} else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }		/* 'b' Means 'busy' --> Reset the Module */
				BOOT_u8TimeOut++;
			}
		} while (BOOT_u8ContFlag == 0);
		/* Length is now Sent, Start Sending Data
		 * GET STATUS
		 * O --> Same Old Firmware in the Flash
		 * N --> New Firmware to be Updated
		 */
		if (BOOT_u8ContFlag != 2) {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"GET http://sobhhhh.freevar.com/FileSettings.txt\r\n");
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == '+') {
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'N' || BOOT_u8Buffer == 'O') { BOOT_u8ContFlag = 1; break; }
				}
				BOOT_u8TimeOut++;
			}
		}
	} while (BOOT_u8ContFlag == 0 || BOOT_u8ContFlag == 2);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[0]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[0]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[1]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[2]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[3]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[4]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[5]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[6]);
	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8AddressBuffer[7]);
}

void BOOT_vEraseSectors(void) {
	u8 BOOT_u8Counter = 1;
	for (; BOOT_u8Counter < _SECTORS_TO_BE_ERASED_+1; BOOT_u8Counter++) { MFMI_vSectorErase(BOOT_u8Counter); }
}

void BOOT_vJumpToApplicationCode(void) {
	/* Set the MSP */
	u32 MSP_VALUE = *((volatile u32*)0x08004000);
	__asm volatile("MSR MSP,%0"::"r"(MSP_VALUE));
	/* Set the Vector Table */
	*((volatile u32*) 0xE000ED08) = 0x08004000;
	/* Jump to the Reset Handler of the APPLICATION CODE */
	void (*BOOT_voidJump)(void);									/* Create a Pointer to Function */
	u32 BOOT_ResetHandlerAddress = *((volatile u32*)0x08004004); 	/* Variable of the Address of the Reset Handler */
	BOOT_voidJump = (void*)BOOT_ResetHandlerAddress;				/* Point it to the Address of the Reset Handler */
	BOOT_voidJump();												/* Jump to the Reset Handler */
}

void BOOT_vReceiveDataRecord(void) {
	do {
		/* Connect using TCP Protocol */
		do {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)CIPSTART);
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }				/* 'b' Means 'busy' --> Reset the Module */
				else if (BOOT_u8Buffer == 'O') {									/* if 'O', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }		/* 'K' Means 'CONNECT\r\nOK' --> break */
					else if (BOOT_u8Buffer == 'R') {BOOT_u8ContFlag = 0; break; }	/* 'R' Means 'ERROR' --> Connect Again */
				} else if (BOOT_u8Buffer == 'Y') {									/* if 'Y', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == ' ') { BOOT_u8ContFlag = 1; break; }		/* ' ' Means 'ALREADY CONNECTED' --> break */
				}
				BOOT_u8TimeOut++;
			}
		} while(BOOT_u8ContFlag == 0);
		/* TCP is now Connected, Send Data Length
		 * AT+CIPSEND=<DataLength>
		 * BOOT_u8ContFlag = 2 --> Skip Data Get URL Command
		 */
		do {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			if (BOOT_u8CounterD2 != '0')      { MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=52\r\n"); }
			else if (BOOT_u8CounterD1 != '0') { MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=51\r\n"); }
			else 							  { MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=50\r\n"); }
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'v') { BOOT_u8ContFlag = 2; break; }		/* 'v' Means 'link is not valid' --> Connect Again */
				else if (BOOT_u8Buffer == 'O') {								/* if 'O', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }	/* 'K' Means '\r\nOK' --> break */
				} else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }	/* 'b' Means 'busy' --> Reset the Module */
				BOOT_u8TimeOut++;
			}
		} while (BOOT_u8ContFlag == 0);
		/* Get the Data Record from the Website */
		if (BOOT_u8ContFlag != 2) {
			MUSART_vTransmitString(ESP8266_USART,(u8*)"GET http://sobhhhh.freevar.com/script.php?line=");
		    if (BOOT_u8CounterD2 != '0') {
		    	/* If Not '0' --> Hundreds */
		    	MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD2);
		        MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD1);
		        MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD0);
		    } else if (BOOT_u8CounterD1 != '0') {
		    	/* If Not '0' --> Tens */
		    	MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD1);
		        MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD0);
		    } else {
		    	/* If Both '0' --> Ones */
		    	MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD0);
		    }
		    MUSART_vTransmitString(ESP8266_USART,(u8*)"\r\n");
		    /* Receive the Data Record */
		    MUSART_vReceiveStringSynchBlocking(ESP8266_USART, BOOT_u8DataRecord);
		}
	} while (BOOT_u8DataRecord[21] != ':' && BOOT_u8DataRecord[22] != ':');
}

void BOOT_vFlashRecord(void) {
	SHPR_vParseHexRecord(&BOOT_u8DataRecord[22]);
	BOOT_u8RecordLength = SHPR_u8GetRecordLength(&BOOT_u8DataRecord[22]);
	SHPR_vParseHexRecord(&BOOT_u8DataRecord[35+(BOOT_u8RecordLength*2)]);
}

void BOOT_vUpdateFirmwareStatus(void) {
	do {
		/* Connect using TCP Protocol */
		do {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)CIPSTART);
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }			/* 'b' Means 'busy' --> Reset the Module */
				else if (BOOT_u8Buffer == 'O') {								/* if 'O', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }	/* 'K' Means 'CONNECT\r\nOK' --> break */
				} else if (BOOT_u8Buffer == 'Y') {								/* if 'Y', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == ' ') { BOOT_u8ContFlag = 1; break; }	/* ' ' Means 'ALREADY CONNECTED' --> break */
				}
				BOOT_u8TimeOut++;
			}
		} while(BOOT_u8ContFlag == 0);
		/* TCP is now Connected, Send Data Length
		 * AT+CIPSEND=<DataLength>
		 * BOOT_u8ContFlag = 2 --> Skip Data Get URL Command
		 */
		do {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=49\r\n");
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'v') { BOOT_u8ContFlag = 2; break; }			/* 'v' Means 'link is not valid' --> Connect Again */
				else if (BOOT_u8Buffer == 'O') {									/* if 'O', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }		/* 'K' Means '\r\nOK' --> break */
				}  else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }		/* 'b' Means 'busy' --> Reset the Module */
				BOOT_u8TimeOut++;
			}
		} while (BOOT_u8ContFlag == 0);
		/* Length is now Sent, Start Sending Data */
		if (BOOT_u8ContFlag != 2) {
			BOOT_u8ContFlag = 0;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"GET http://sobhhhh.freevar.com/script.php?end\r\n");
			/* Read the Buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'O') {											/* if 'O', Read Next Element */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }		/* 'K' Means '\r\nOK' --> break */
				}  else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }		/* 'b' Means 'busy' --> Reset the Module */
				BOOT_u8TimeOut++;
			}
		}
	} while (BOOT_u8ContFlag == 0 || BOOT_u8ContFlag == 2);
	BOOT_vCloseConnection();
}

void BOOT_vCloseConnection(void) {
	do {
		BOOT_u8ContFlag = 0;
		BOOT_u8TimeOut = 0;
		MUSART_vTransmitString(ESP8266_USART, (u8*)"AT+CIPCLOSE\r\n");
	    /* Read Buffer */
	    while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
	    	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
	    	if (BOOT_u8Buffer == 'O') {												/* if 'O', Read Next Element */
	    		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
	    		if (BOOT_u8Buffer == 'K') { BOOT_u8ContFlag = 1; break; }			/* 'K' Means '\r\nOK' --> break */
	    	} else if (BOOT_u8Buffer == 'E') {										/* if 'E', Read Next Element */
	    		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
	    		if (BOOT_u8Buffer == 'R') { BOOT_u8ContFlag = 1; break; }			/* 'R' Means '\r\nERROR' --> break */
	    	} else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }			/* 'b' Means 'busy' --> Reset the Module */
	    	BOOT_u8TimeOut++;
	    }
	} while (BOOT_u8ContFlag == 0);
}
